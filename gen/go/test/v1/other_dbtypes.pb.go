// Code generated by protoc-gen-go-dbtypes. DO NOT EDIT.
// source: test/v1/other.proto

package testv1

import (
	driver "database/sql/driver"
	fmt "fmt"
	proto "google.golang.org/protobuf/proto"
)

// ProtoValue wraps a protobuf message for database scanning/valuing.
type ProtoValue[T proto.Message] struct {
	Message T
}

// Scan implements sql.Scanner.
func (p *ProtoValue[T]) Scan(src any) error {
	if src == nil {
		return nil
	}

	var data []byte
	switch v := src.(type) {
	case []byte:
		data = v
	case string:
		data = []byte(v)
	default:
		return fmt.Errorf("dbtypes: unsupported scan type: %T", src)
	}

	return proto.Unmarshal(data, p.Message)
}

// Value implements driver.Valuer.
func (p *ProtoValue[T]) Value() (driver.Value, error) {
	if any(p.Message) == nil {
		return nil, nil
	}
	return proto.Marshal(p.Message)
}

// AnotherMessageValue wraps *AnotherMessage for database operations.
type AnotherMessageValue struct {
	*ProtoValue[*AnotherMessage]
}

// NewAnotherMessageValue creates a new AnotherMessageValue wrapper.
func NewAnotherMessageValue(msg *AnotherMessage) *AnotherMessageValue {
	if msg == nil {
		msg = &AnotherMessage{}
	}
	return &AnotherMessageValue{
		ProtoValue: &ProtoValue[*AnotherMessage]{Message: msg},
	}
}

// Scan implements sql.Scanner.
func (x *AnotherMessageValue) Scan(src any) error {
	if x.ProtoValue == nil {
		x.ProtoValue = &ProtoValue[*AnotherMessage]{Message: &AnotherMessage{}}
	}
	if x.ProtoValue.Message == nil {
		x.ProtoValue.Message = &AnotherMessage{}
	}
	return x.ProtoValue.Scan(src)
}

// Value implements driver.Valuer.
func (x *AnotherMessageValue) Value() (driver.Value, error) {
	if x.ProtoValue == nil {
		return nil, nil
	}
	return x.ProtoValue.Value()
}

// Unwrap returns the underlying protobuf message.
func (x *AnotherMessageValue) Unwrap() *AnotherMessage {
	if x.ProtoValue == nil || x.ProtoValue.Message == nil {
		return nil
	}
	return x.ProtoValue.Message
}

// DatabaseValue returns a database-compatible wrapper for this message.
func (x *AnotherMessage) DatabaseValue() *AnotherMessageValue {
	return NewAnotherMessageValue(x)
}

// SecondMessageValue wraps *SecondMessage for database operations.
type SecondMessageValue struct {
	*ProtoValue[*SecondMessage]
}

// NewSecondMessageValue creates a new SecondMessageValue wrapper.
func NewSecondMessageValue(msg *SecondMessage) *SecondMessageValue {
	if msg == nil {
		msg = &SecondMessage{}
	}
	return &SecondMessageValue{
		ProtoValue: &ProtoValue[*SecondMessage]{Message: msg},
	}
}

// Scan implements sql.Scanner.
func (x *SecondMessageValue) Scan(src any) error {
	if x.ProtoValue == nil {
		x.ProtoValue = &ProtoValue[*SecondMessage]{Message: &SecondMessage{}}
	}
	if x.ProtoValue.Message == nil {
		x.ProtoValue.Message = &SecondMessage{}
	}
	return x.ProtoValue.Scan(src)
}

// Value implements driver.Valuer.
func (x *SecondMessageValue) Value() (driver.Value, error) {
	if x.ProtoValue == nil {
		return nil, nil
	}
	return x.ProtoValue.Value()
}

// Unwrap returns the underlying protobuf message.
func (x *SecondMessageValue) Unwrap() *SecondMessage {
	if x.ProtoValue == nil || x.ProtoValue.Message == nil {
		return nil
	}
	return x.ProtoValue.Message
}

// DatabaseValue returns a database-compatible wrapper for this message.
func (x *SecondMessage) DatabaseValue() *SecondMessageValue {
	return NewSecondMessageValue(x)
}
