package main

import (
	"google.golang.org/protobuf/compiler/protogen"
)

const (
	driverPackage = protogen.GoImportPath("database/sql/driver")
	protoPackage  = protogen.GoImportPath("google.golang.org/protobuf/proto")
	fmtPackage    = protogen.GoImportPath("fmt")
)

// GeneratorConfig holds configuration options for the generator.
type GeneratorConfig struct {
	ExcludedTypes map[string]bool
	OnlyPackage   string
}

func generateFile(gen *protogen.Plugin, file *protogen.File, config *GeneratorConfig, generatedPackages map[protogen.GoImportPath]bool) error {
	// Skip if package filter is set and doesn't match
	if config.OnlyPackage != "" && string(file.Desc.Package()) != config.OnlyPackage {
		return nil
	}

	// Filter messages that should have wrappers generated
	var messages []*protogen.Message
	for _, m := range file.Messages {
		if shouldGenerateWrapper(m, config) {
			messages = append(messages, m)
		}
	}

	if len(messages) == 0 {
		return nil
	}

	filename := file.GeneratedFilenamePrefix + "_dbtypes.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	generateHeader(g, file)

	// Only generate ProtoValue once per package
	if !generatedPackages[file.GoImportPath] {
		generateProtoValueType(g)
		generatedPackages[file.GoImportPath] = true
	}

	// Generate wrapper for each message
	for _, m := range messages {
		generateMessageWrapper(g, m)
	}

	return nil
}

func shouldGenerateWrapper(m *protogen.Message, config *GeneratorConfig) bool {
	// Skip map entries
	if m.Desc.IsMapEntry() {
		return false
	}

	// Skip excluded types
	if config.ExcludedTypes[m.GoIdent.GoName] {
		return false
	}

	// Also check the full proto name (e.g., "test.v1.ToolSetSpec")
	if config.ExcludedTypes[string(m.Desc.FullName())] {
		return false
	}

	// Generate for all other messages
	return true
}

func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-go-dbtypes. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
}

func generateProtoValueType(g *protogen.GeneratedFile) {
	g.P("// ProtoValue wraps a protobuf message for database scanning/valuing.")
	g.P("type ProtoValue[T ", protoPackage.Ident("Message"), "] struct {")
	g.P("	Message T")
	g.P("}")
	g.P()

	// Scan method
	g.P("// Scan implements sql.Scanner.")
	g.P("func (p *ProtoValue[T]) Scan(src any) error {")
	g.P("	if src == nil {")
	g.P("		return nil")
	g.P("	}")
	g.P()
	g.P("	var data []byte")
	g.P("	switch v := src.(type) {")
	g.P("	case []byte:")
	g.P("		data = v")
	g.P("	case string:")
	g.P("		data = []byte(v)")
	g.P("	default:")
	g.P("		return ", fmtPackage.Ident("Errorf"), `("dbtypes: unsupported scan type: %T", src)`)
	g.P("	}")
	g.P()
	g.P("	return ", protoPackage.Ident("Unmarshal"), "(data, p.Message)")
	g.P("}")
	g.P()

	// Value method
	g.P("// Value implements driver.Valuer.")
	g.P("func (p *ProtoValue[T]) Value() (", driverPackage.Ident("Value"), ", error) {")
	g.P("	if any(p.Message) == nil {")
	g.P("		return nil, nil")
	g.P("	}")
	g.P("	return ", protoPackage.Ident("Marshal"), "(p.Message)")
	g.P("}")
	g.P()
}

func generateMessageWrapper(g *protogen.GeneratedFile, m *protogen.Message) {
	typeName := m.GoIdent.GoName
	wrapperName := typeName + "Value"

	// Type definition
	g.P("// ", wrapperName, " wraps *", typeName, " for database operations.")
	g.P("type ", wrapperName, " struct {")
	g.P("	*ProtoValue[*", typeName, "]")
	g.P("}")
	g.P()

	// Constructor
	g.P("// New", wrapperName, " creates a new ", wrapperName, " wrapper.")
	g.P("func New", wrapperName, "(msg *", typeName, ") *", wrapperName, " {")
	g.P("	if msg == nil {")
	g.P("		msg = &", typeName, "{}")
	g.P("	}")
	g.P("	return &", wrapperName, "{")
	g.P("		ProtoValue: &ProtoValue[*", typeName, "]{Message: msg},")
	g.P("	}")
	g.P("}")
	g.P()

	// Scan method
	g.P("// Scan implements sql.Scanner.")
	g.P("func (x *", wrapperName, ") Scan(src any) error {")
	g.P("	if x.ProtoValue == nil {")
	g.P("		x.ProtoValue = &ProtoValue[*", typeName, "]{Message: &", typeName, "{}}")
	g.P("	}")
	g.P("	if x.ProtoValue.Message == nil {")
	g.P("		x.ProtoValue.Message = &", typeName, "{}")
	g.P("	}")
	g.P("	return x.ProtoValue.Scan(src)")
	g.P("}")
	g.P()

	// Value method
	g.P("// Value implements driver.Valuer.")
	g.P("func (x *", wrapperName, ") Value() (", driverPackage.Ident("Value"), ", error) {")
	g.P("	if x.ProtoValue == nil {")
	g.P("		return nil, nil")
	g.P("	}")
	g.P("	return x.ProtoValue.Value()")
	g.P("}")
	g.P()

	// Unwrap helper
	g.P("// Unwrap returns the underlying protobuf message.")
	g.P("func (x *", wrapperName, ") Unwrap() *", typeName, " {")
	g.P("	if x.ProtoValue == nil || x.ProtoValue.Message == nil {")
	g.P("		return nil")
	g.P("	}")
	g.P("	return x.ProtoValue.Message")
	g.P("}")
	g.P()
}
